-- â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®

-- â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block End â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

-- â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
--p: create git repo with with  the current folder name and push to github => add readme.md with the project information
local function createGitRepoAndPushToGithub()
	-- Get the current working directory
	local cwd = vim.fn.getcwd()

	-- Get the system username
	local username = vim.fn.system("whoami"):gsub("%s+", "")

	-- Get the current date and time
	local date_time = os.date("%d/%m/%Y %I:%M %p %a GMT+6")

	-- Define the location
	local location = "Sharifpur, Gazipur, Dhaka"

	-- Default repository name to root directory name
	local repo_name = vim.fn.fnamemodify(cwd, ":t")
	local live_site = "http://shahjalal-labs.surge.sh/"
	local portfolio_github = "https://github.com/shahjalal-labs/shahjalal-portfolio"
	local portfolio_live = "http://shahjalal-labs.surge.sh/"
	local linkedin = "https://www.linkedin.com/in/md-sj-825bb4341/"
	local facebook = "https://www.facebook.com/profile.php?id=61556383702555"
	local youtube = "https://www.youtube.com/@muhommodshahjalal9811"

	-- Prompt for repository name (non-blocking) with default
	vim.ui.input({ prompt = "Enter the repository name: ", default = repo_name }, function(input)
		repo_name = input or repo_name -- Use input if provided, otherwise use default
		local github_url = "https://github.com/shahjalal-labs/" .. repo_name

		-- Notify starting status
		vim.cmd("redrawstatus")
		vim.cmd("echo 'Initializing repository...'")

		-- Prepare README.md content

		local readme_content = string.format(
			[[# ğŸŒŸ %s

## ğŸ“‚ Project Information

| ğŸ“ **Detail**           | ğŸ“Œ **Value**                                                              |
|------------------------|---------------------------------------------------------------------------|
| ğŸ”— **GitHub URL**       | [%s](%s)                                                                  |
| ğŸŒ **Live Site**        | [%s](%s)                                                                  |
| ğŸ’» **Portfolio GitHub** | [%s](%s)                                                                  |
| ğŸŒ **Portfolio Live**   | [%s](%s)                                                                  |
| ğŸ“ **Directory**        | `%s`                                                                      |
| ğŸ‘¤ **Username**         | `%s`                                                                      |
| ğŸ“… **Created On**       | `%s`                                                                      |
| ğŸ“ **Location**         | %s                                                                        |
| ğŸ’¼ **LinkedIn**         | [%s](%s)                                                                  |
| ğŸ“˜ **Facebook**         | [%s](%s)                                                                  |
| â–¶ï¸ **YouTube**          | [%s](%s)                                                                  |

---

> ğŸš€ Auto-generated by your Neovim setup  
> ğŸ§  Modify this template for even more detail or project-specific features.
]],
			repo_name,
			github_url,
			github_url,
			live_site,
			live_site,
			portfolio_github,
			portfolio_github,
			portfolio_live,
			portfolio_live,
			cwd,
			username,
			date_time,
			location,
			linkedin,
			linkedin,
			facebook,
			facebook,
			youtube,
			youtube
		)
		-- Check if README.md exists and append content at the top
		local readme_file_path = "README.md"
		local readme_content_with_existing = readme_content

		if vim.fn.filereadable(readme_file_path) == 1 then
			local existing_content = table.concat(vim.fn.readfile(readme_file_path), "\n")
			readme_content_with_existing = readme_content .. "\n" .. existing_content
		end

		-- Write the README.md file
		local readme_file = io.open(readme_file_path, "w")
		readme_file:write(readme_content_with_existing)
		readme_file:close()

		-- Initialize Git repository and handle errors
		local init_result = vim.fn.system("git init")
		if vim.v.shell_error ~= 0 then
			vim.notify("Error initializing Git repository: " .. init_result, vim.log.levels.ERROR)
			return
		end

		local add_result = vim.fn.system("git add .")
		if vim.v.shell_error ~= 0 then
			vim.notify("Error adding files to Git: " .. add_result, vim.log.levels.ERROR)
			return
		end

		local commit_result = vim.fn.system("git commit -m 'Initial commit'")
		if vim.v.shell_error ~= 0 then
			vim.notify("Error committing files to Git: " .. commit_result, vim.log.levels.ERROR)
			return
		end

		local branch_result = vim.fn.system("git branch -M main")
		if vim.v.shell_error ~= 0 then
			vim.notify("Error renaming branch to main: " .. branch_result, vim.log.levels.ERROR)
			return
		end

		-- Create GitHub repository and push, handle errors
		local command = string.format("gh repo create %s --public --source=. --remote=origin --push", repo_name)
		local result = vim.fn.system(command)

		if vim.v.shell_error ~= 0 then
			vim.notify("Error creating or pushing to GitHub repository: " .. result, vim.log.levels.ERROR)
			return
		end

		-- Notify user about the successful creation and push of the repository
		vim.cmd("redrawstatus")
		vim.notify("Repository created and pushed successfully!", vim.log.levels.INFO)

		-- Open the new GitHub repository in the browser
		local open_url_command = string.format("xdg-open %s", github_url) -- For Linux; change as needed for other OSes.
		os.execute(open_url_command)

		-- Display result in the status line
		vim.cmd("echo 'GitHub repository created and pushed!'")
	end)
end

-- Map the function to <leader>gj
vim.keymap.set("n", "<leader>gj", createGitRepoAndPushToGithub, { noremap = true, silent = true })

-- â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block End â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

-- â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
--t: git push from neovim
function GitPushFromNvim()
	-- Prompt for commit message
	local commit_message = vim.fn.input("Enter commit message: ")

	-- Ensure the commit message is not empty
	if commit_message == "" then
		print("Commit message cannot be empty. Aborting.")
		return
	end

	-- Execute the git commands sequentially
	vim.cmd("!git add .")
	vim.cmd("!git commit -m '" .. commit_message .. "'")
	vim.cmd("!git push -u origin main")
end
vim.api.nvim_set_keymap("n", "<space>aj", ":lua GitPushFromNvim()<CR>", { noremap = true, silent = true })

-- â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block End â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

-- â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
-- STEP 1: Generate smart commit message with file filtering
-- local function generate_git_summary()
-- 	local ignored_patterns = {
-- 		"%.env$",
-- 		"%.lock$",
-- 		"node_modules/",
-- 		"%.DS_Store$",
-- 	}
--
-- 	local function should_ignore(file)
-- 		for _, pattern in ipairs(ignored_patterns) do
-- 			if file:match(pattern) then
-- 				return true
-- 			end
-- 		end
-- 		return false
-- 	end
--
-- 	local git_diff = vim.fn.systemlist("git diff --cached --name-status")
-- 	if not git_diff or #git_diff == 0 then
-- 		return nil
-- 	end
--
-- 	local summary = {}
--
-- 	for _, line in ipairs(git_diff) do
-- 		local status, file = line:match("^(%a)%s+(.+)$")
-- 		if file and not should_ignore(file) then
-- 			if status == "A" then
-- 				table.insert(summary, "ğŸ†• Added: " .. file)
-- 			elseif status == "M" then
-- 				table.insert(summary, "âœï¸ Updated: " .. file)
-- 			elseif status == "D" then
-- 				table.insert(summary, "ğŸ—‘ï¸ Removed: " .. file)
-- 			end
-- 		end
-- 	end
--
-- 	if #summary == 0 then
-- 		return nil
-- 	end
--
-- 	return table.concat(summary, " | ")
-- end
--
-- -- STEP 2: Git add + commit + push
-- local function intelligent_git_push()
-- 	local cwd = vim.fn.getcwd()
--
-- 	-- git add .
-- 	vim.fn.jobstart({ "bash", "-c", "cd " .. cwd .. " && git add ." }, {
-- 		on_exit = function()
-- 			local msg = generate_git_summary()
-- 			if not msg then
-- 				vim.notify("âš ï¸ Nothing to commit", vim.log.levels.INFO)
-- 				return
-- 			end
--
-- 			local cmd = string.format([[cd "%s" && git commit -m "%s" && git push]], cwd, msg)
--
-- 			vim.fn.jobstart({ "bash", "-c", cmd }, {
-- 				detach = true,
-- 				on_exit = function(_, code)
-- 					if code == 0 then
-- 						vim.notify("âœ… Git pushed: " .. msg, vim.log.levels.INFO)
-- 					else
-- 						vim.notify("âŒ Git push failed", vim.log.levels.ERROR)
-- 					end
-- 				end,
-- 			})
-- 		end,
-- 	})
-- end
--
-- -- STEP 3: Command
-- vim.api.nvim_create_user_command("GitSmartPush", function()
-- 	intelligent_git_push()
-- end, {})
--
-- -- STEP 4: Keybind <leader>gp
-- vim.keymap.set("n", "<leader>gb", intelligent_git_push, { desc = "ğŸ’¡ Git Smart Push" })
--
-- -- STEP 5: Auto push every 30 seconds (testing)
-- local timer = vim.loop.new_timer()
-- timer:start(0, 30000, vim.schedule_wrap(intelligent_git_push))
--
-- -- â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block End â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

-- â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
--w: 29/11/2024 06:50 PM Fri GMT+6 Sharifpur, Gazipur, Dhaka
--p: run git remote -v from neovim , dynamically selec the tmux pane number
function RunGitRemoteInTmuxPane()
	-- Prompt the user for the tmux pane number
	local pane_number = vim.fn.input("Enter the tmux pane number: "):gsub("%s+", "")

	if pane_number == "" then
		vim.notify("No pane number provided. Operation canceled.", vim.log.levels.ERROR)
		return
	end

	-- Stop any running process in the specified tmux pane
	local stop_command = "tmux send-keys -t " .. pane_number .. " C-c"
	vim.fn.system(stop_command)

	-- Wait briefly to ensure the process is stopped
	vim.wait(200)

	-- Clear the tmux pane before running the new command
	local clear_command = "tmux send-keys -t " .. pane_number .. " C-l"
	vim.fn.system(clear_command)

	-- Wait briefly before sending the git remote command
	vim.wait(100)

	-- Send the git remote -v command
	local git_command = "tmux send-keys -t " .. pane_number .. ' "git remote -v" C-m'
	vim.fn.system(git_command)

	-- Notify the user
	vim.notify("Ran `git remote -v` in tmux pane " .. pane_number, vim.log.levels.INFO)
end

-- Bind the function to a key combination
vim.keymap.set("n", "<leader>ar", RunGitRemoteInTmuxPane, { desc = "Run `git remote -v` in specified tmux pane" })
-- â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Block End â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
